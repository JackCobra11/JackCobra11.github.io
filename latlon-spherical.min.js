/**
 * Minified by jsDelivr using Terser v3.14.1.
 * Original file: /gh/chrisveness/geodesy@2.0.0/latlon-spherical.js
 * 
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import Dms from"./dms.js";const π=Math.PI;class LatLonSpherical{constructor(a,t){if(isNaN(a))throw new TypeError(`Invalid lat ‘${a}’`);if(isNaN(t))throw new TypeError(`Invalid lon ‘${t}’`);this._lat=Dms.wrap90(a),this._lon=Dms.wrap180(t)}get lat(){return this._lat}get latitude(){return this._lat}set lat(a){if(this._lat=isNaN(a)?Dms.wrap90(Dms.parse(a)):Dms.wrap90(a),isNaN(this._lat))throw new TypeError(`Invalid lat ‘${a}’`)}set latitude(a){if(this._lat=isNaN(a)?Dms.wrap90(Dms.parse(a)):Dms.wrap90(a),isNaN(this._lat))throw new TypeError(`Invalid latitude ‘${a}’`)}get lon(){return this._lon}get lng(){return this._lon}get longitude(){return this._lon}set lon(a){if(this._lon=isNaN(a)?Dms.wrap180(Dms.parse(a)):Dms.wrap180(a),isNaN(this._lon))throw new TypeError(`Invalid lon ‘${a}’`)}set lng(a){if(this._lon=isNaN(a)?Dms.wrap180(Dms.parse(a)):Dms.wrap180(a),isNaN(this._lon))throw new TypeError(`Invalid lng ‘${a}’`)}set longitude(a){if(this._lon=isNaN(a)?Dms.wrap180(Dms.parse(a)):Dms.wrap180(a),isNaN(this._lon))throw new TypeError(`Invalid longitude ‘${a}’`)}static get metresToKm(){return.001}static get metresToMiles(){return 1/1609.344}static get metresToNauticalMiles(){return 1/1852}static parse(...a){if(0==a.length)throw new TypeError("Invalid (empty) coordinate");if(null===a[0]||null===a[1])throw new TypeError("Invalid (null) coordinate");let t=void 0,n=void 0;if(2==a.length&&([t,n]=a,t=Dms.wrap90(Dms.parse(t)),n=Dms.wrap180(Dms.parse(n)),isNaN(t)||isNaN(n)))throw new TypeError(`Invalid coordinate ‘${a.toString()}’`);if(1==a.length&&"string"==typeof a[0]&&([t,n]=a[0].split(","),t=Dms.wrap90(Dms.parse(t)),n=Dms.wrap180(Dms.parse(n)),isNaN(t)||isNaN(n)))throw new TypeError(`Invalid coordinate ‘${a[0]}’`);if(1==a.length&&"object"==typeof a[0]){const s=a[0];if("Point"==s.type&&Array.isArray(s.coordinates)?[n,t]=s.coordinates:(null!=s.latitude&&(t=s.latitude),null!=s.lat&&(t=s.lat),null!=s.longitude&&(n=s.longitude),null!=s.lng&&(n=s.lng),null!=s.lon&&(n=s.lon),t=Dms.wrap90(Dms.parse(t)),n=Dms.wrap180(Dms.parse(n))),isNaN(t)||isNaN(n))throw new TypeError(`Invalid coordinate ‘${JSON.stringify(a[0])}’`)}if(isNaN(t)||isNaN(n))throw new TypeError(`Invalid coordinate ‘${a.toString()}’`);return new LatLonSpherical(t,n)}distanceTo(a,t=6371e3){if(a instanceof LatLonSpherical||(a=LatLonSpherical.parse(a)),isNaN(t))throw new TypeError("Radius is not a number");const n=t,s=this.lat.toRadians(),i=this.lon.toRadians(),o=a.lat.toRadians(),e=o-s,h=a.lon.toRadians()-i,r=Math.sin(e/2)*Math.sin(e/2)+Math.cos(s)*Math.cos(o)*Math.sin(h/2)*Math.sin(h/2);return n*(2*Math.atan2(Math.sqrt(r),Math.sqrt(1-r)))}initialBearingTo(a){a instanceof LatLonSpherical||(a=LatLonSpherical.parse(a));const t=this.lat.toRadians(),n=a.lat.toRadians(),s=(a.lon-this.lon).toRadians(),i=Math.cos(t)*Math.sin(n)-Math.sin(t)*Math.cos(n)*Math.cos(s),o=Math.sin(s)*Math.cos(n),e=Math.atan2(o,i).toDegrees();return Dms.wrap360(e)}finalBearingTo(a){a instanceof LatLonSpherical||(a=LatLonSpherical.parse(a));const t=a.initialBearingTo(this)+180;return Dms.wrap360(t)}midpointTo(a){a instanceof LatLonSpherical||(a=LatLonSpherical.parse(a));const t=this.lat.toRadians(),n=this.lon.toRadians(),s=a.lat.toRadians(),i=(a.lon-this.lon).toRadians(),o=Math.cos(s)*Math.cos(i),e=Math.cos(s)*Math.sin(i),h=Math.sqrt((Math.cos(t)+o)*(Math.cos(t)+o)+e*e),r=Math.sin(t)+Math.sin(s),l=Math.atan2(r,h),M=n+Math.atan2(e,Math.cos(t)+o),c=l.toDegrees(),p=M.toDegrees();return new LatLonSpherical(c,Dms.wrap180(p))}intermediatePointTo(a,t){a instanceof LatLonSpherical||(a=LatLonSpherical.parse(a));const n=this.lat.toRadians(),s=this.lon.toRadians(),i=a.lat.toRadians(),o=a.lon.toRadians(),e=i-n,h=o-s,r=Math.sin(e/2)*Math.sin(e/2)+Math.cos(n)*Math.cos(i)*Math.sin(h/2)*Math.sin(h/2),l=2*Math.atan2(Math.sqrt(r),Math.sqrt(1-r)),M=Math.sin((1-t)*l)/Math.sin(l),c=Math.sin(t*l)/Math.sin(l),p=M*Math.cos(n)*Math.cos(s)+c*Math.cos(i)*Math.cos(o),d=M*Math.cos(n)*Math.sin(s)+c*Math.cos(i)*Math.sin(o),L=M*Math.sin(n)+c*Math.sin(i),u=Math.atan2(L,Math.sqrt(p*p+d*d)),m=Math.atan2(d,p),g=u.toDegrees(),w=m.toDegrees();return new LatLonSpherical(g,Dms.wrap180(w))}destinationPoint(a,t,n=6371e3){const s=a/n,i=Number(t).toRadians(),o=this.lat.toRadians(),e=this.lon.toRadians(),h=Math.sin(o)*Math.cos(s)+Math.cos(o)*Math.sin(s)*Math.cos(i),r=Math.asin(h),l=Math.sin(i)*Math.sin(s)*Math.cos(o),M=Math.cos(s)-Math.sin(o)*h,c=e+Math.atan2(l,M),p=r.toDegrees(),d=c.toDegrees();return new LatLonSpherical(p,Dms.wrap180(d))}static intersection(a,t,n,s){a instanceof LatLonSpherical||(a=LatLonSpherical.parse(a)),n instanceof LatLonSpherical||(n=LatLonSpherical.parse(n));const i=a.lat.toRadians(),o=a.lon.toRadians(),e=n.lat.toRadians(),h=n.lon.toRadians(),r=Number(t).toRadians(),l=Number(s).toRadians(),M=e-i,c=h-o,p=2*Math.asin(Math.sqrt(Math.sin(M/2)*Math.sin(M/2)+Math.cos(i)*Math.cos(e)*Math.sin(c/2)*Math.sin(c/2)));if(0==p)return null;const d=(Math.sin(e)-Math.sin(i)*Math.cos(p))/(Math.sin(p)*Math.cos(i)),L=(Math.sin(i)-Math.sin(e)*Math.cos(p))/(Math.sin(p)*Math.cos(e)),u=Math.acos(Math.min(Math.max(d,-1),1)),m=Math.acos(Math.min(Math.max(L,-1),1)),g=r-(Math.sin(h-o)>0?u:2*π-u),w=(Math.sin(h-o)>0?2*π-m:m)-l;if(0==Math.sin(g)&&0==Math.sin(w))return null;if(Math.sin(g)*Math.sin(w)<0)return null;const D=-Math.cos(g)*Math.cos(w)+Math.sin(g)*Math.sin(w)*Math.cos(p),R=Math.atan2(Math.sin(p)*Math.sin(g)*Math.sin(w),Math.cos(w)+Math.cos(g)*D),N=Math.asin(Math.sin(i)*Math.cos(R)+Math.cos(i)*Math.sin(R)*Math.cos(r)),f=o+Math.atan2(Math.sin(r)*Math.sin(R)*Math.cos(i),Math.cos(R)-Math.sin(i)*Math.sin(N)),S=N.toDegrees(),T=f.toDegrees();return new LatLonSpherical(S,Dms.wrap180(T))}crossTrackDistanceTo(a,t,n=6371e3){a instanceof LatLonSpherical||(a=LatLonSpherical.parse(a)),t instanceof LatLonSpherical||(t=LatLonSpherical.parse(t));const s=n,i=a.distanceTo(this,s)/s,o=a.initialBearingTo(this).toRadians(),e=a.initialBearingTo(t).toRadians();return Math.asin(Math.sin(i)*Math.sin(o-e))*s}alongTrackDistanceTo(a,t,n=6371e3){a instanceof LatLonSpherical||(a=LatLonSpherical.parse(a)),t instanceof LatLonSpherical||(t=LatLonSpherical.parse(t));const s=n,i=a.distanceTo(this,s)/s,o=a.initialBearingTo(this).toRadians(),e=a.initialBearingTo(t).toRadians(),h=Math.asin(Math.sin(i)*Math.sin(o-e));return Math.acos(Math.cos(i)/Math.abs(Math.cos(h)))*Math.sign(Math.cos(e-o))*s}maxLatitude(a){const t=Number(a).toRadians(),n=this.lat.toRadians();return Math.acos(Math.abs(Math.sin(t)*Math.cos(n))).toDegrees()}static crossingParallels(a,t,n){const s=Number(n).toRadians(),i=a.lat.toRadians(),o=a.lon.toRadians(),e=t.lat.toRadians(),h=t.lon.toRadians()-o,r=Math.sin(i)*Math.cos(e)*Math.cos(s)*Math.sin(h),l=Math.sin(i)*Math.cos(e)*Math.cos(s)*Math.cos(h)-Math.cos(i)*Math.sin(e)*Math.cos(s),M=Math.cos(i)*Math.cos(e)*Math.sin(s)*Math.sin(h);if(M*M>r*r+l*l)return null;const c=Math.atan2(-l,r),p=Math.acos(M/Math.sqrt(r*r+l*l)),d=o+c+p,L=(o+c-p).toDegrees(),u=d.toDegrees();return{lon1:Dms.wrap180(L),lon2:Dms.wrap180(u)}}rhumbDistanceTo(a,t=6371e3){a instanceof LatLonSpherical||(a=LatLonSpherical.parse(a));const n=t,s=this.lat.toRadians(),i=a.lat.toRadians(),o=i-s;let e=Math.abs(a.lon-this.lon).toRadians();Math.abs(e)>π&&(e=e>0?-(2*π-e):2*π+e);const h=Math.log(Math.tan(i/2+π/4)/Math.tan(s/2+π/4)),r=Math.abs(h)>1e-11?o/h:Math.cos(s);return Math.sqrt(o*o+r*r*e*e)*n}rhumbBearingTo(a){a instanceof LatLonSpherical||(a=LatLonSpherical.parse(a));const t=this.lat.toRadians(),n=a.lat.toRadians();let s=(a.lon-this.lon).toRadians();Math.abs(s)>π&&(s=s>0?-(2*π-s):2*π+s);const i=Math.log(Math.tan(n/2+π/4)/Math.tan(t/2+π/4)),o=Math.atan2(s,i).toDegrees();return Dms.wrap360(o)}rhumbDestinationPoint(a,t,n=6371e3){const s=this.lat.toRadians(),i=this.lon.toRadians(),o=Number(t).toRadians(),e=a/n,h=e*Math.cos(o);let r=s+h;Math.abs(r)>π/2&&(r=r>0?π-r:-π-r);const l=Math.log(Math.tan(r/2+π/4)/Math.tan(s/2+π/4)),M=Math.abs(l)>1e-11?h/l:Math.cos(s),c=i+e*Math.sin(o)/M,p=r.toDegrees(),d=c.toDegrees();return new LatLonSpherical(p,Dms.wrap180(d))}rhumbMidpointTo(a){a instanceof LatLonSpherical||(a=LatLonSpherical.parse(a));const t=this.lat.toRadians();let n=this.lon.toRadians();const s=a.lat.toRadians(),i=a.lon.toRadians();Math.abs(i-n)>π&&(n+=2*π);const o=(t+s)/2,e=Math.tan(π/4+t/2),h=Math.tan(π/4+s/2),r=Math.tan(π/4+o/2);let l=((i-n)*Math.log(r)+n*Math.log(h)-i*Math.log(e))/Math.log(h/e);isFinite(l)||(l=(n+i)/2);const M=o.toDegrees(),c=l.toDegrees();return new LatLonSpherical(M,Dms.wrap180(c))}static areaOf(a,t=6371e3){const n=t,s=a[0].equals(a[a.length-1]);s||a.push(a[0]);const i=a.length-1;let o=0;for(let t=0;t<i;t++){const n=a[t].lat.toRadians(),s=a[t+1].lat.toRadians(),i=(a[t+1].lon-a[t].lon).toRadians();o+=2*Math.atan2(Math.tan(i/2)*(Math.tan(n/2)+Math.tan(s/2)),1+Math.tan(n/2)*Math.tan(s/2))}(function(a){let t=0,n=a[0].initialBearingTo(a[1]);for(let s=0;s<a.length-1;s++){const i=a[s].initialBearingTo(a[s+1]),o=a[s].finalBearingTo(a[s+1]);t+=(i-n+540)%360-180,t+=(o-i+540)%360-180,n=o}const s=a[0].initialBearingTo(a[1]);return t+=(s-n+540)%360-180,Math.abs(t)<90})(a)&&(o=Math.abs(o)-2*π);const e=Math.abs(o*n*n);return s||a.pop(),e}equals(a){return a instanceof LatLonSpherical||(a=LatLonSpherical.parse(a)),this.lat==a.lat&&this.lon==a.lon}toGeoJSON(){return{type:"Point",coordinates:[this.lon,this.lat]}}toString(a="d",t){if(!["d","dm","dms","n"].includes(a))throw new RangeError(`Invalid format ‘${a}’`);if("n"==a)return null==t&&(t=4),`${this.lat.toFixed(t)},${this.lon.toFixed(t)}`;return`${Dms.toLat(this.lat,a,t)}, ${Dms.toLon(this.lon,a,t)}`}}export{LatLonSpherical as default,Dms};
//# sourceMappingURL=/sm/7f8c0feaec4809d94373616ac46c4ba1ccbdbb531f1045f01ae7e980b4b044ef.map